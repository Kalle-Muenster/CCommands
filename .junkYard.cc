/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      junkYard.cc                                ||
||     Author:    Autogenerated                              ||
||     Generated: 17.11.2020                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _OnTheFly_
  #include ".CheckForProjectSettings.h"
  #include ".junkYard.h"
#endif

#include <stdlib.h>

yard* junk_yard = NULL;

///////////////////////////////////////////////////////////////////////////////
// not exported 'yard_' internal api functions

yard* junk_getYard(void)
{
#if defined( using_commandLiner ) && defined( WITH_JUNKYARD ) && (!defined(CLINE_INTERNAL))
    if (!isCleansening()) {
#if DEBUG
        printf("%s(): will try fetching 'junk' dingens from commander!\n", __FUNCTION__);
#endif
        return (yard*)getDingens("junk");
    }
#endif
    return junk_yard;
}

yard* junk_setYard( yard* junkyard )
{
#if defined( using_commandLiner ) && defined( WITH_JUNKYARD ) && (!defined( CLINE_INTERNAL ))
    if ( junkyard ) {
        if ( !junk_yard ) {
      #if DEBUG
            printf( "setting up a commandLiner dingens for attaching a JunkYard instance\n" );
      #endif
            addDingens( "junk", (junk_yard=junkyard), &junk_dropYard );
        }
    } else if ( junk_yard ) {
        remDingens( "junk" );
        junk_yard = junkyard;
    } return junk_yard;
#else
  #if DEBUG
    printf( "WARNING: the junkYard is setup referenced as global pointer. no junk_dropAllChunks() won't be called atexit() so\n" );
  #endif
    if(!junk_yard) {
        junk_yard = junkyard;
    } else if (!junkyard) {
        junk_yard = junkyard;
    } return junk_yard;
#endif
}

#if DEBUG
int junk_counter = 0;
int junk_removed = 0;
#endif

yard* ejectPull( void* chunk )
{
    Junk* This = (Junk*)chunk;
    Junk* Next = (Junk*)This->next;
    This->next = NULL;
    void* junk = (void*)This->self;
    void* call = This->dtor;
    int CASE = (junk ? 1 : 0) | (call ? 2 : 0);
    switch (CASE) {
        case 1: break;
        case 2: ((cmDtCall)call)(); break;
        case 3: ((cmDtFunc)call)(junk); break;
    } return Next;
}

void dropZone( void* chunk )
{
  #if DEBUG
    ++junk_counter;
  #endif
    Junk* This = (Junk*)chunk;
    Junk* next = (Junk*)This->next;
    This->next = NULL;
    if( next ) {
      #if DEBUG
        printf( "%s(): enter next deeper level: %p\n", __FUNCTION__, next );
      #endif
         // next->drop = &dropZone;
        // next->drop( next );
       // drop is recursive..., for regular cases it should be a
      // function pointer to this function: dropZone(nextDrop)
        next->drop( next );
        free( next );
      #if DEBUG
        if (--junk_counter > 0)
            printf( "%s(): removed %i pieces from junkyard\n", __FUNCTION__, junk_removed - junk_counter );
      #endif
        next = NULL; }
  #if DEBUG
    else next = (Junk*)(ptval)-1;
    printf( "%s(): for chunk: %p\n", __FUNCTION__, chunk );
  #endif
    int CASE = (This->self ? 1 : 0);
    CASE = CASE | (This->dtor ? 2 : 0);
    switch( CASE ) {
        case 1:{
            #if DEBUG
            printf("...droped destructorless chunk of junk: %p\n",This);
            #endif
        break; }
        case 2:{
            #if DEBUG
            printf("...calling cleansener registered for junk-chunk: %p\n",This);
            #endif
            (*(cmDtCall)This->dtor)();
        break;}
        case 3:{
            #if DEBUG
            printf("...calling cleansener of object allocated at: %p\n", This->self );
            #endif
            (*(cmDtFunc)This->dtor)( (void*)This->self );
        break;}
        default: break; }
    This->dtor = NULL;
    This->self = NULL;
    This->hold = NULL;
  #if DEBUG
    if ( next ) {
        junk_removed = junk_counter;
        printf("%s(): found chunk number %i seem to be last chunk %p\n",__FUNCTION__, junk_counter, This );
    }
  #endif
}

// desintegrate 'that' chunk
Junk* yard_takeOff( ptval that, yard* chunk )
{
    Junk* found;
    if ( chunk ) {
        if( that == chunk->self ) {
            chunk->drop = (cmDtFunc)&ejectPull;
            found = chunk;
        } else {
            found = yard_takeOff( that, (yard*)chunk->next );
            if( found == chunk->next ) {
                chunk->next = found->next;
                found->next = NULL;
            }
        }
    } else found = NULL;
    return found;
}

// integrate ready initialized chunk of junk (verpackung) within the junkyard
void yard_addDestructorChunk( Junk* chunk )
{
    Junk* current = junk_getYard();
    if( current )   {
        while( current->next )
               current = (Junk*)current->next;
        current->next = chunk;
    } else {
        junk_yard = junk_setYard( chunk );
#if defined(using_commandLiner)
        yard* test = (yard*)getDingens( "junk" );
        if ( test != junk_yard ) {
            printf( "%s(): ERROR\n", __FUNCTION__ );
        }
#endif
    }
#if DEBUG
    printf( "%s(): added a cleansener for mem chunk: %p\n", __FUNCTION__, chunk );
#endif
}

void* yard_initializeJunkChunk( void* junkchunk )
{
    Junk* chunk = (Junk*)junkchunk;
    chunk->hold = (ptval)&chunk->self;
    chunk->drop = &dropZone;
    chunk->self = (ptval)&((ptval*)junkchunk)[5]; // offset to the actual data
    chunk->dtor = NULL;
    chunk->next = NULL;
    yard_addDestructorChunk( chunk );
    return (void*)chunk->self;
}

Junk* yard_allocateJustOnlyJunk( void* distantMemory )
{
    Junk* chunk = (Junk*)malloc( sizeof(Junk) );
    chunk->hold = (ptval)&chunk->self;
    chunk->drop = &dropZone;
    chunk->self = (ptval)distantMemory;
    chunk->dtor = NULL;
    chunk->next = NULL;
    yard_addDestructorChunk( chunk );
    return chunk;
}

///////////////////////////////////////////////////////////////////////////////
// callable junkYard (exported?) 'junk_' api

void* junk_initializeJunkObject( cmDtFunc dtr, void* object )
{
    Junk* chunk = (Junk*)object;
    chunk->hold = (ptval)&chunk->hold;
    chunk->drop = &dropZone;
    chunk->self = (ptval)&((ptval*)object)[5];
    chunk->dtor = dtr;
    chunk->next = NULL;
    yard_addDestructorChunk( chunk );
    return (void*)chunk->self;
}


void  junk_installCleansener( cmDtCall func )
{
    Junk* chunk = (Junk*)malloc(sizeof(Junk));
    chunk->hold = (ptval)&chunk->hold;
    chunk->drop = &dropZone;
    chunk->dtor = (cmDtFunc)(void*)func;
    chunk->self = NULL;
    chunk->next = NULL;
    yard_addDestructorChunk( chunk );
}

// allocate cbSize bytes of memory and coveres that in some chunk of junk (something
// like a 'verpackung') which (when 'hold' grip variable inside that junk-chunk header
// may be set to null) will be freed via ejector calls on the junkyard or (always, 
// regardless wether hold grip may be null or not) at shuttdown with dropping whole yard
// it returns a pointer to the requested 'cbSize' bytes on raw memory
// (which is allocated on the junkyard with same malloc call together with the verpackung
// and begins directly afterwards, with first byte address which follws the verpackung)
void* junk_allocateJunkChunk( uint cbSize )
{
#if DEBUG
    void* ptChunk = yard_initializeJunkChunk( malloc( cbSize + sizeof(Junk) ) );
    printf("%s(): %i byte 'data' at address %p\n", __FUNCTION__, cbSize, ptChunk );
    return ptChunk;
#endif
    return yard_initializeJunkChunk( malloc( cbSize + sizeof(Junk) ) );
}

void* junk_registerJunkChunk( void* distMem )
{
#if DEBUG
    yard_allocateJustOnlyJunk( distMem );
    printf("%s(): for holding unknown count on bytes 'alien' data at address %p\n", __FUNCTION__, distMem );
    return distMem;
#endif
    yard_allocateJustOnlyJunk( distMem );
    return distMem;
}


// allocates objSize count on bytes covered in a 'verpackunks' chunk but additionally 
// places a given function pointer within the verpackungs header structure. this 
// function in case the object isn't used anymore, will be called automatically by the
// junkyard before that would free the allocated memory in case junk_cycle() called.
// The dtor function will access the data as always the last operation accessing the 
// data before this in the last step will get lost with being freed.
void* junk_allocateNewObject( cmDtFunc objDtor, uint objSize )
{
#if DEBUG
    void* ptObject = junk_initializeJunkObject( objDtor, malloc( sizeof(Junk) + objSize ) );
    printf( "%s(): of size %i byte, at address %p\n", __FUNCTION__, objSize, ptObject );
    return ptObject;
#endif
    return junk_initializeJunkObject( objDtor, malloc( sizeof(Junk) + objSize ) );
}

// caution! junk_drop() function is ineffective for any alien data
// chunks which will be integrated via junk_objectivateMemory(anydata)
// when data before was not allocated via using the junkyard api also
// then this data just only could be freed later again if the same alien 
// api which also was used for allocating the chunk is used for this...
// anyway it is possible creating an object from some alien data chunk:
// The funtion passed as the destructor then must take care about freeing
// up ALL data completely on it's own then. for doing this, it can use
// any api what ever was used once before for allocating the memory
void* junk_objectivateMemory( cmDtFunc objDtor, void* objMem )
{
#if DEBUG
    yard_allocateJustOnlyJunk( objMem )->dtor = objDtor;
    printf( "%s(): unknown sized 'alien' object at address %p\n", __FUNCTION__, objMem );
    return objMem;
#endif
    yard_allocateJustOnlyJunk( objMem )->dtor = objDtor;
    return objMem;
}

// frees all memory allocated on the junk yard. should be called at 
// shuttdown (commandLiner installes an atexit handled dingsbums)
void junk_dropYard( void )
{
    yard* junkyard = junk_getYard();
    if( junkyard ) {
      #if DEBUG
       printf( "%s(): begin cleansening the junk yard located at: %p\n", __FUNCTION__, junkyard );
      #endif

        dropZone( junkyard );

      #if DEBUG
       printf( "%s(): done with cleansening junk yard! (removed %i pieces from: %p)\n", __FUNCTION__, junk_removed, junkyard );
      #endif
        free( junkyard );
        junk_setYard( NULL );
    }
}

// doing one drop-loop cycle (finds chunks marked for deletion and
// calls destructors for these before freeing up allocated memory) 
void junk_cycle( void )
{
    yard* junkyard = junk_getYard();
    void* loeschi;
    while( junkyard ) {
        if( junkyard->hold ) {
            junkyard = junkyard->next;
        } else {
            if( junkyard->drop == &dropZone ) {
                junkyard->drop = (cmDtFunc)&ejectPull;
            } junkyard = (yard*)((cmDtPunk)junkyard->drop)( loeschi = junkyard );
            free( loeschi );
        }
    }
}

// delete it at once! ( do not wait for the next junk_cycle() call )
ptval junk_free( void* chunk )
{
	yard* found = yard_takeOff( (ptval)chunk, junk_getYard() );
    if( found ) {
        chunk = (void*)(ptval)((cmDtPunk)found->drop)( found );
        free( found );
    } return (ptval)chunk;
}

#define SELF 3
#define HOLD 5

// mark it recycable... ( gets deleted with next junk_cycle() call )
ptval junk_drop( void* kannweg )
{
    ptdif pointer = (ptdif)kannweg;
	if( kannweg == (void*)*(ptval*)(pointer - sizeof(ptval) * SELF) ) {
		return ((Junk*)(pointer - sizeof(ptval) * HOLD))->hold = NULL;
	} else {
		return junk_free( kannweg );
	}
}

#undef SELF
#undef HOLD
