/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      autostart.cc                               ||
||     Author:    autogenerated                              ||
||     Generated: by Command Generator v.0.1                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _OnTheFly_
  #include ".autostart.h"
#else
  #include <.commandLiner.h>

  int USAGE(autostart)
  {
    Synopsis("<modus> [name] [command]");
    printf("Modi:\n\n\
    --add <name> <command> : registers given <command> below given <name> to be executed every system start\n\
    --nxt <command>        : registers given <command> to get executed with the next system start (only once)\n\
    --lst                  : lists all entries which before had been registered via 'autostart --add' call\n\
    --rem <name>           : unregister that command which before has been registered below givin <name>\n\n\
    (*mode parameter may be given by shorter one leter form '-a, -n, -l, -r' also )\n\n");
    return CheckForError()
        || !hasOption('h');
  }
#endif

// regular includes here:
#include <stdlib.h>


void autostart_add(const char* name, const char* command)
{
    pool_setCheckpoint();
    pool_set("REG ADD HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v ");
    pool_set(name);
    pool_set(" /t REG_SZ /d \"");
    pool_set(unQuoted(command));
    pool_set("\"");
    cmLn regcmd = pool_collectCheckpoint();
    if( hasOption('v') )
        printf( "%s\n", regcmd );
    if ( system(regcmd) == 0 )
        listedFeature( ADD_TO_LIST, "AUTOSTART_ENTRIES", name );
    else setError("failed adding reg entry",FourCC("reg"));
}

void autostart_nxt(const char* command)
{
    pool_setCheckpoint();
    pool_set("REG ADD HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce /v ");
    pool_set("CommandLinerAddedStartOnce");
    pool_set(" /t REG_SZ /d \"");
    pool_set(unQuoted(command));
    pool_set("\"");
    cmLn regcmd = pool_collectCheckpoint();
    if ( hasOption('v') )
        printf( "%s\n", regcmd );
    if ( system(regcmd) != 0 )
        setError("failed adding reg entry",FourCC("reg"));
}

cmLn autostart_lst(void)
{
    FeatureGet fet = getFeatured( "AUTOSTART_ENTRIES" );
    if ( fet.type.flags & Type_LISTER ) {
        for ( int i=0; i < fet.type.size[1]; ++i )
            pool_setf( "%s\n", fet.value.lister[i] );
        return pool_merge( fet.type.size[1] );
    } else if ( fet.type.flags & Type_STRING ) {
        return pool_setf("%s\n",fet.value.string);
    }
}

void autostart_rem( const char* name )
{
    pool_set("REG DELETE HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v \"");
    pool_set(name);
    pool_set("\"");
    cmLn regcmd = pool_merge(3);
    if ( hasOption('v') )
        printf( "%s\n", regcmd );
    if ( system(regcmd) != 0 )
        setError("failed removing reg entry",FourCC("reg"));
    else listedFeature( REMOVE_FROM, "AUTOSTART_ENTRIES", name );
}



#ifdef autostart
int main(int argc,char**argv)
{
    if( (!InitCommandLiner(argc,argv))
        ||hasOption('h') ) {
        exit(USAGE(autostart));
    }

    if( !isAnyModusAtAll() ) {
    if( search('a') ) {
        setOption( 'N', getName('a') );
        setOption( 'C', rawNext('a') );
        setModus( "add" );
    } else if( search('n') ) {
        setOption( 'C', getName('n') );
        setModus( "nxt" );
    } else if( search('r') ) {
        setOption( 'N', getName('r') );
        setModus( "rem" );
    } else if ( isSwitch('l') ) {
        setModus( "lst" );
    }
    }

    if (hasOption('v'))
        showOptions();

    if( !isAnyModusAtAll() ) {
        exit(USAGE(autostart));
    }

    if ( isModus( "add" ) )
    {
        if ( isEmptyArg( getName('N') ) ) {
            cmLn name = rawNext('a');
            if ( isEmptyArg( name ) ) {
                setError("missing 'name' parameter","ctx");
            } else {
                switchIdx( 'N', indexOfName(name) );
            }
        }
        if ( isEmptyArg( getName('C') ) ) {
            cmLn command = rawName(1);
            if ( isEmptyArg( command ) ) {
                setError("missing 'command' parameter","ctx");
            } else {
                switchIdx( 'C', indexOfName(command) );
            }
        } ExitOnError("Parameter");
        autostart_add( getName('N'), getName('C') );
    }
    else
    if ( isModus( "lst" ) )
    {
        printf("\nRegistered Autostart entries:\n\n%s",
            autostart_lst()
        );
    }
    else
    if ( isModus( "nxt" ) ) {
        if( isEmptyArg( getName( 'C' ) ) ) {
            cmLn command = rawNext('n');
            if ( isEmptyArg( command ) ) {
                setError("missing 'command' parameter","ctx");
            } else {
                switchIdx( 'C', indexOfName(command) );
            }
        } ExitOnError("Parameter");
        autostart_nxt( getName('C') );
    }
    else
    if ( isModus( "rem" ) )
    {
        if ( isEmptyArg( getName('N') ) ) {
            cmLn name = rawNext('r');
            if ( isEmptyArg( name ) ) {
                setError("missing 'name' parameter","ctx");
            } else {
                switchIdx( 'N', indexOfName(name) );
            }
        } ExitOnError("Parameter");
        autostart_rem( getName('N') );
    }

    exit(CheckForError());
}

#endif
